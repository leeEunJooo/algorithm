[k14j]
먼저 설명 하기 전에 제 코드에 정렬을 하는 코드가 있는데 의미가 없습니다.
그냥 시간이 줄어드는지 확인하려고 한 것이니 신경쓰지 말아주세요.

1. 코드 설명

첫번째로 그래프 설정에 관하여 얘기하겠습니다.

arr 에는 출발지인 (0,0) , node 1부터 node n의 (x,y)좌표, (z,z)가 저장되어있습니다.

이 arr의 각각 원소를 그래프의 node로 생각합시다.

두번째로 얘기할 것은 w값의 범위입니다.

w값의 범위는 최소 1, 최대 10000 * sqrt(2) 입니다.
lo = 1, hi = 10000 * sqrt(2) (14143)으로 선언했습니다.

이제 parametric search를 할 것인데 먼저 함수 f(w) 를 정의하겠습니다.

f(w) : w라는 배터리 무게로 (0,0)인 지점에서 (z, z) 지점을 갈 수 있나?
갈 수 있으면 1, 갈 수 없으면 0을 반환

w와 f(w)의 관계를 그려보면 아래와 같이 될 것입니다.

 w

1

2

3

...

k - 1

k

k + 1

...

14143

f(w) 

0

0

0

... 

0

1

1

...

1


여기서 우리는 f(w)가 1인 w중에 최소의 값을 찾아야 합니다. 실제 정답을 k라고 합시다.

lo와 hi의 중간 지점인 mid를 잡고 f(mid)를 call 합니다.

f(mid)가 1이라면 lo <= k <= mid 입니다. 그래서 hi = mid - 1을 해줍니다.
이렇게 하면 다음 반복문 에서 lo와 hi 사이에 k가 있게 됩니다.

반대로 f(mid)가 0이라면 mid <= k <= hi 입니다. 그래서 lo = mid + 1을 해줍니다.
마찬 가지로 이렇게 범위를 바꿔 주면 lo 와 hi 사이에 k가 있게 됩니다.

bfs(mid * mid)에서 인자를 mid * mid를 넘겨주는 이유는 node i 에서 node j로 갈 수 있는지를 확인 할 건데
미리 해놓지 않으면 각각 node를 확인 할 때마다 곱연산을 해야하는데 거기서 시간을 쓸데 없이 잡을 것 같아서
호출 시에 mid * mid를 넘깁니다.

마지막에 lo를 출력하는 이유는 이러합니다.
마지막으로 수행된 반복문의 lo와 hi는 같습니다. 그리고 f(lo), f(hi)는 둘다 1이어야 할 것입니다.
그러면 bfs(mid * mid)의 결과는 1이고, hi = mid - 1이 되어 이 반복문은 종료합니다. lo > hi이기 때문이죠.
그렇게 되면 lo가 문제의 정답이 됩니다.

최종적으로 제가 작성한 알고리즘의 시간복잡도는 O(n2 * log z) 입니다.

2. 아쉬운 점

뭐가 아쉬웠냐면 제 bfs에서는 node i에서 node j를 갈 수 있는지를 확인할 때
i에서 j까지 거리를 계산 하는데 그 계산을 전처리 했으면 더 빨라졌을 것이라고 생각했습니다.
실제로 저보다 더 빠른 두분도 전처리 되어있는 부분이 보이네요.
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[nono5546]
기본 아이디어 -

1. 가장 짧은 경우는 1111.....1111 이다.

2. N으로 갈 수 있는 길이 하나라도 있으면 된다.

를 베이스로 잡고 시작하였습니다.



저는 vector<pair<int,int>> 형의 자료구조에 (0,0) (... N개의 좌표...) (Z,Z) 를 넣어주었습니다. (총 N+2개)

그 후, N+2 X N+2 크기의 2차원 벡터에 각각 점에서 점까지의 거리를 모두 계산하여 넣어주었습니다.



저는 bfs가 아니라 dfs로 풀었습니다. 처음에는 limit을 1씩 올리며 Z점에 도착하면 종단에서 1을 리턴하는 코드를 짰습니다.

visit vector를 다시 초기화하지 않는 이유는 양방향으로 거리가 똑같기때문에 한번 방문한 점을 다시 방문하는 것은 

의미가 없다고 판단하였기 때문입니다. 또한, 얼마나 오래 걸리는지 확인하기 위하여 경로가 완성되었을때 탈출하는 부분을 넣지 않았습니다.

위와 같이 작성한 첫 제출때, 1.4초 정도 나왔습니다.



시간을 줄이기 위한 노력-

1. 거리를 1씩 올리지 않고 이진탐색으로 확인.

  - 1씩 올렸을때 갈 수 있는 길이 어차피 적기 때문에, 오히려 끝까지 가야하는 이진탐색이 더 오래걸릴거라 생각했으나,

    훨씬 짧게 걸려 0.7초정도로 줄었습니다.

2. Z까지 길이 완성되었을때, 탈출 분기.

  - 효과적으로 적용되어, 최종 결과인 0.295초로 줄었습니다.



그 외에, N+2 X N+2 의 길 계산을 미리 다 해놓지 않고,

필요할 때에, 없으면 계산하고 있으면 사용하는 방법을 적용해보려 했으나,

dfs시에 계산된 길이가 있는지 없는지 확인하는 횟수가 너무 많아 오히려 손해였습니다.

수정해서 적용해보려 했으나, 제출 횟수가 모자라 포기했습니다.

btr만 전역으로 사용된다거나, cnt에 덧셈으로 들어가는 등의 코드상 어색한 부분은

대부분 이런 수정상 문제입니다.
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
[hadan]
저는 교수님이 수업시간에 말씀해주신 BFS및 이진탐색 기법을 활용해서 문제를 풀었습니다.

먼저 x,y좌표를 저장할수있는 노드를 선언하고 입력받은 n값과 x,y좌표를 기반으로 노드를 생성합니다.

단 첫번째 노드는 0(,0)의 좌표를 지나고 마지막 n+2번째 노드는 (z,z)를 지납니다.

그리고 distinction 이라는 함수로 각 노드에서 노드까지의 거리를 float형 배열 dist에 저장합니다.

while문의 조건에 들어가는 wl과 wr은 노드끼리의 최소거리인 1과 n*sqrt(2)로 설정했으며

wl값과 wr값에 해당하는 pivot값을 기준으로 해서 BFS를 실행한뒤 입력받은 pivot길이에 대한 경로가 존재하는 경우(return 1)와 경로가 존재하지 않는 경우(return 0)로 나누어

존재할시 pivot보다 긴 길이 즉,pivot+1~wr를 버리기위해 wr=pivot으로 설정한뒤 다시 bfs를 돌리며

존재하지 않을경우 pivot과 pivot보다 짧은 길이 즉,wl~pivot을 버리기 위해 wl=pivot으로 설정한뒤 다시 bfs를 돌립니다.

pivot값을 기준으로 계속 binary search를 하다보면 최소 pivot값을 구할수있습니다.



BFS내에서는 앞으로 탐색할 노드를 저장할 queue와 탐색이 완료된 노드들을 저장할 expset, 그리고 frontier안에 노드가 존재하는지 확인해줄 ftcheck을 설정하고

queue에 노드0을 넣은뒤 queue가 빌때까지 BFS를 실행합니다. 



BFS는 간단합니다.

queue에서 노드를 빼주고 나온 노드는 ftcheck에 0으로 표시

그리고 이 노드가 최종목적지인지 확인한후 맞으면 1을 반환 아니면

pivot값을 기준으로 해서 이 노드와의 거리가 pivot이하이고 queue나 expset에 들어가있지않은 노드들을 다시 queue에 넣습니다.

그후 이 노드를 ftcheck에서 1로 표시합니다.

queue가 빌때까지 이 작업을 반복합니다.

만약 queue가 비어 while을 나오게된다면 0을 반환합니다.



제출할때 깔끔하게 정리하지않고 그대로 내다보니 코드가 좀 지저분하고 쓸데없는부분이 많네요

노드 클래스안에있는 int배열 dp나 print 그리고 전역변수로 선언된 frval같은건 무시하셔도 됩니다.

